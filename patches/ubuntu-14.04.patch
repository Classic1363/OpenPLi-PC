diff -ruN b/lib/gdi/picload.cpp a/lib/gdi/picload.cpp
--- b/lib/gdi/picload.cpp	2019-12-06 20:50:26.892711285 +0300
+++ a/lib/gdi/picload.cpp	2019-12-06 20:49:15.000000000 +0300
@@ -2,12 +2,10 @@
 #include <png.h>
 #include <fcntl.h>
 
-#include <lib/base/cfile.h>
 #include <lib/gdi/picload.h>
+#include <lib/gdi/picexif.h>
 
 extern "C" {
-#define HAVE_BOOLEAN
-#define boolean int
 #include <jpeglib.h>
 #include <gif_lib.h>
 }
@@ -26,12 +24,61 @@
 	return tmp;
 }
 
+static unsigned char *simple_resize_24(unsigned char *orgin, int ox, int oy, int dx, int dy)
+{
+	unsigned char *cr = new unsigned char[dx * dy * 3];
+	if (cr == NULL)
+	{
+		eDebug("[Picload] Error malloc");
+		return orgin;
+	}
+	const int stride = 3 * dx;
+	#pragma omp parallel for
+	for (int j = 0; j < dy; ++j)
+	{
+		unsigned char* k = cr + (j * stride);
+		const unsigned char* p = orgin + (j * oy / dy * ox) * 3;
+		for (int i = 0; i < dx; i++)
+		{
+			const unsigned char* ip = p + (i * ox / dx) * 3;
+			*k++ = ip[0];
+			*k++ = ip[1];
+			*k++ = ip[2];
+		}
+	}
+	delete [] orgin;
+	return cr;
+}
+
+static unsigned char *simple_resize_8(unsigned char *orgin, int ox, int oy, int dx, int dy)
+{
+	unsigned char* cr = new unsigned char[dx * dy];
+	if (cr == NULL)
+	{
+		eDebug("[Picload] Error malloc");
+		return(orgin);
+	}
+	const int stride = dx;
+	#pragma omp parallel for
+	for (int j = 0; j < dy; ++j)
+	{
+		unsigned char* k = cr + (j * stride);
+		const unsigned char* p = orgin + (j * oy / dy * ox);
+		for (int i = 0; i < dx; i++)
+		{
+			*k++ = p[i * ox / dx];
+		}
+	}
+	delete [] orgin;
+	return cr;
+}
+
 static unsigned char *color_resize(unsigned char * orgin, int ox, int oy, int dx, int dy)
 {
 	unsigned char* cr = new unsigned char[dx * dy * 3];
 	if (cr == NULL)
 	{
-		eDebug("[ePicLoad] resize Error malloc");
+		eDebug("[Picload] Error malloc");
 		return orgin;
 	}
 	const int stride = 3 * dx;
@@ -94,10 +141,7 @@
 	lseek(fd, BMP_COLOR_OFFSET, SEEK_SET);
 	for (int i = 0; i < count; i++)
 	{
-		if (read(fd, buff, 4) != 4) // failed to read rgb
-		{
-			break;
-		}
+		read(fd, buff, 4);
 		pallete[i].red = buff[2];
 		pallete[i].green = buff[1];
 		pallete[i].blue = buff[0];
@@ -112,39 +156,15 @@
 	int fd = open(file, O_RDONLY);
 	if (fd == -1) return NULL;
 	if (lseek(fd, BMP_SIZE_OFFSET, SEEK_SET) == -1) return NULL;
-	if (read(fd, buff, 4) != 4) // failed to read x
-	{
-		close(fd);
-		return NULL;
-	}
+	read(fd, buff, 4);
 	*x = buff[0] + (buff[1] << 8) + (buff[2] << 16) + (buff[3] << 24);
-	if (read(fd, buff, 4) != 4) // failed to read y
-	{
-		close(fd);
-		return NULL;
-	}
+	read(fd, buff, 4);
 	*y = buff[0] + (buff[1] << 8) + (buff[2] << 16) + (buff[3] << 24);
-	if (lseek(fd, BMP_TORASTER_OFFSET, SEEK_SET) == -1)
-	{
-		close(fd);
-		return NULL;
-	}
-	if (read(fd, buff, 4) != 4) // failed to read raster
-	{
-		close(fd);
-		return NULL;
-	}
+	if (lseek(fd, BMP_TORASTER_OFFSET, SEEK_SET) == -1) return NULL;
+	read(fd, buff, 4);
 	int raster = buff[0] + (buff[1] << 8) + (buff[2] << 16) + (buff[3] << 24);
-	if (lseek(fd, BMP_BPP_OFFSET, SEEK_SET) == -1)
-	{
-		close(fd);
-		return NULL;
-	}
-	if (read(fd, buff, 2) != 2) // failed to read bpp
-	{
-		close(fd);
-		return NULL;
-	}
+	if (lseek(fd, BMP_BPP_OFFSET, SEEK_SET) == -1) return NULL;
+	read(fd, buff, 2);
 	int bpp = buff[0] + (buff[1] << 8);
 
 	unsigned char *pic_buffer = new unsigned char[(*x) * (*y) * 3];
@@ -162,10 +182,7 @@
 				return NULL;
 			for (int i = 0; i < *y; i++)
 			{
-				if (read(fd, tbuffer, (*x) / 2 + *x % 2) != ((*x) / 2 + *x % 2))
-				{
-					eDebug("[ePicLoad] failed to read %d bytes...", ((*x) / 2 + *x % 2));
-				}
+				read(fd, tbuffer, (*x) / 2 + *x % 2);
 				int j;
 				for (j = 0; j < (*x) / 2; j++)
 				{
@@ -186,15 +203,10 @@
 					*wr_buffer++ = pallete[c1].blue;
 				}
 				if (skip)
-				{
-					if (read(fd, buff, skip) != skip)
-					{
-						eDebug("[ePicLoad] failed to read %d bytes...", skip);
-					}
-				}
+					read(fd, buff, skip);
 				wr_buffer -= (*x) * 6;
 			}
-			delete [] tbuffer;
+			delete tbuffer;
 			break;
 		}
 		case 8:
@@ -207,10 +219,7 @@
 				return NULL;
 			for (int i = 0; i < *y; i++)
 			{
-				if (read(fd, tbuffer, *x) != *x)
-				{
-					eDebug("[ePicLoad] failed to read %d bytes...", *x);
-				}
+				read(fd, tbuffer, *x);
 				for (int j = 0; j < *x; j++)
 				{
 					wr_buffer[j * 3] = pallete[tbuffer[j]].red;
@@ -218,15 +227,10 @@
 					wr_buffer[j * 3 + 2] = pallete[tbuffer[j]].blue;
 				}
 				if (skip)
-				{
-					if (read(fd, buff, skip) != skip)
-					{
-						eDebug("[ePicLoad] failed to skip %d bytes...", skip);
-					}
-				}
+					read(fd, buff, skip);
 				wr_buffer -= (*x) * 3;
 			}
-			delete [] tbuffer;
+			delete tbuffer;
 			break;
 		}
 		case 24:
@@ -235,10 +239,7 @@
 			lseek(fd, raster, SEEK_SET);
 			for (int i = 0; i < (*y); i++)
 			{
-				if (read(fd, wr_buffer, (*x) * 3) != ((*x) * 3))
-				{
-					eDebug("[picload] failed to read %d bytes...", ((*x) * 3));
-				}
+				read(fd, wr_buffer, (*x) * 3);
 				for (int j = 0; j < (*x) * 3 ; j = j + 3)
 				{
 					unsigned char c = wr_buffer[j];
@@ -246,12 +247,7 @@
 					wr_buffer[j + 2] = c;
 				}
 				if (skip)
-				{
-					if (read(fd, buff, skip) != skip)
-					{
-						eDebug("[ePicLoad] failed to skip %d bytes...", skip);
-					}
-				}
+					read(fd, buff, skip);
 				wr_buffer -= (*x) * 3;
 			}
 			break;
@@ -267,29 +263,35 @@
 
 //---------------------------------------------------------------------
 
-static void png_load(Cfilepara* filepara, int background, bool forceRGB=false)
+static void png_load(Cfilepara* filepara, int background)
 {
 	png_uint_32 width, height;
 	unsigned int i;
 	int bit_depth, color_type, interlace_type;
 	png_byte *fbptr;
-	CFile fh(filepara->file, "rb");
-	if (!fh)
+	FILE *fh = fopen(filepara->file, "rb");
+
+	if (fh == NULL)
 		return;
 
 	png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
 	if (png_ptr == NULL)
+	{
+		fclose(fh);
 		return;
+	}
 	png_infop info_ptr = png_create_info_struct(png_ptr);
 	if (info_ptr == NULL)
 	{
 		png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);
+		fclose(fh);
 		return;
 	}
 
 	if (setjmp(png_jmpbuf(png_ptr)))
 	{
 		png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
+		fclose(fh);
 		return;
 	}
 
@@ -298,7 +300,7 @@
 	png_read_info(png_ptr, info_ptr);
 	png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, &interlace_type, NULL, NULL);
 
-	if (!forceRGB && (color_type == PNG_COLOR_TYPE_GRAY || color_type & PNG_COLOR_MASK_PALETTE))
+	if (color_type == PNG_COLOR_TYPE_GRAY || color_type & PNG_COLOR_MASK_PALETTE)
 	{
 		if (bit_depth < 8)
 		{
@@ -346,13 +348,13 @@
 	}
 	else
 	{
+		if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
+			png_set_expand(png_ptr);
 		if (bit_depth == 16)
 			png_set_strip_16(png_ptr);
 		if (color_type == PNG_COLOR_TYPE_GRAY || color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
 			png_set_gray_to_rgb(png_ptr);
-		if (color_type & PNG_COLOR_MASK_PALETTE)
-			png_set_palette_to_rgb(png_ptr);
-		if (color_type & PNG_COLOR_MASK_ALPHA || png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
+		if ((color_type == PNG_COLOR_TYPE_RGB_ALPHA) || (color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
 		{
 			png_set_strip_alpha(png_ptr);
 			png_color_16 bg;
@@ -363,12 +365,14 @@
 			bg.index = 0;
 			png_set_background(png_ptr, &bg, PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);
 		}
+		int number_passes = png_set_interlace_handling(png_ptr);
 		png_read_update_info(png_ptr, info_ptr);
 
 		if (width * 3 != png_get_rowbytes(png_ptr, info_ptr))
 		{
-			eDebug("[ePicLoad] Error processing (did not get RGB data from PNG file)");
+			eDebug("[Picload] Error processing (did not get RGB data from PNG file)");
 			png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
+			fclose(fh);
 			return;
 		}
 
@@ -377,7 +381,6 @@
 		filepara->oy = height;
 		filepara->pic_buffer = pic_buffer;
 
-		int number_passes = png_set_interlace_handling(png_ptr);
 		for(int pass = 0; pass < number_passes; pass++)
 		{
 			fbptr = (png_byte *)pic_buffer;
@@ -387,6 +390,7 @@
 		png_read_end(png_ptr, info_ptr);
 	}
 	png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
+	fclose(fh);
 }
 
 //-------------------------------------------------------------------
@@ -410,10 +414,10 @@
 	struct jpeg_decompress_struct cinfo;
 	struct jpeg_decompress_struct *ciptr = &cinfo;
 	struct r_jpeg_error_mgr emgr;
+	FILE *fh;
 	unsigned char *pic_buffer=NULL;
-	CFile fh(file, "rb");
 
-	if (!fh)
+	if (!(fh = fopen(file, "rb")))
 		return NULL;
 
 	ciptr->err = jpeg_std_error(&emgr.pub);
@@ -421,6 +425,7 @@
 	if (setjmp(emgr.envbuffer) == 1)
 	{
 		jpeg_destroy_decompress(ciptr);
+		fclose(fh);
 		return NULL;
 	}
 
@@ -428,22 +433,24 @@
 	jpeg_stdio_src(ciptr, fh);
 	jpeg_read_header(ciptr, TRUE);
 	ciptr->out_color_space = JCS_RGB;
-
+	int s = 8;
 	if (max_x == 0) max_x = 1280; // sensible default
 	if (max_y == 0) max_y = 720;
-	// define scale to always fit vertically or horizontally in all orientations
-	ciptr->scale_denom = 8;
-	unsigned int screenmax = max_x > max_y ? max_x : max_y;
-	unsigned int imagemin  = ciptr->image_width < ciptr->image_height ? ciptr->image_width : ciptr->image_height;
-	ciptr->scale_num = (ciptr->scale_denom * screenmax + imagemin -1) / imagemin;
-	if (ciptr->scale_num < 1)  ciptr->scale_num = 1;
-	if (ciptr->scale_num > 16) ciptr->scale_num = 16;
+	while (s != 1)
+	{
+		if ((ciptr->image_width >= (s * max_x)) ||
+		    (ciptr->image_height >= (s * max_y)))
+			break;
+		s /= 2;
+	}
+	ciptr->scale_num = 1;
+	ciptr->scale_denom = s;
 
 	jpeg_start_decompress(ciptr);
 
 	*ox=ciptr->output_width;
 	*oy=ciptr->output_height;
-	//eDebug("[jpeg_load] ox=%d oy=%d w=%d (%d), h=%d (%d) scale=%d rec_outbuf_height=%d", ciptr->output_width, ciptr->output_height, ciptr->image_width, max_x, ciptr->image_height, max_y, ciptr->scale_num, ciptr->rec_outbuf_height);
+	// eDebug("jpeg_read ox=%d oy=%d w=%d (%d), h=%d (%d) scale=%d rec_outbuf_height=%d", ciptr->output_width, ciptr->output_height, ciptr->image_width, max_x, ciptr->image_height, max_y, ciptr->scale_denom, ciptr->rec_outbuf_height);
 
 	if(ciptr->output_components == 3)
 	{
@@ -459,6 +466,7 @@
 	}
 	jpeg_finish_decompress(ciptr);
 	jpeg_destroy_decompress(ciptr);
+	fclose(fh);
 	return(pic_buffer);
 }
 
@@ -467,20 +475,19 @@
 {
 	struct jpeg_compress_struct cinfo;
 	struct jpeg_error_mgr jerr;
+	FILE * outfile;
 	JSAMPROW row_pointer[1];
 	int row_stride;
-	CFile outfile(filename, "wb");
-
-	if (!outfile)
-	{
-		eDebug("[ePicLoad] jpeg can't write %s: %m", filename);
-		return 1;
-	}
 
 	cinfo.err = jpeg_std_error(&jerr);
 	jpeg_create_compress(&cinfo);
 
-	eDebug("[ePicLoad] save Thumbnail... %s",filename);
+	if ((outfile = fopen(filename, "wb")) == NULL)
+	{
+		eDebug("[Picload] jpeg can't open %s", filename);
+		return 1;
+	}
+	eDebug("[Picload] save Thumbnail... %s",filename);
 
 	jpeg_stdio_dest(&cinfo, outfile);
 
@@ -498,6 +505,7 @@
 		(void) jpeg_write_scanlines(&cinfo, row_pointer, 1);
 	}
 	jpeg_finish_compress(&cinfo);
+	fclose(outfile);
 	jpeg_destroy_compress(&cinfo);
 	return 0;
 }
@@ -517,10 +525,11 @@
 	}
 }
 
-static void gif_load(Cfilepara* filepara, bool forceRGB = false)
+static void gif_load(Cfilepara* filepara)
 {
 	unsigned char *pic_buffer = NULL;
 	int px, py, i, j;
+	unsigned char *fbptr;
 	unsigned char *slb=NULL;
 	GifFileType *gft;
 	GifRecordType rt;
@@ -529,10 +538,13 @@
 	int cmaps;
 	int extcode;
 
-#if GIFLIB_MAJOR > 5 || GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1
-	gft = DGifOpenFileName(filepara->file, &extcode);
-#else
+#if !defined(GIFLIB_MAJOR) || ( GIFLIB_MAJOR < 5)
 	gft = DGifOpenFileName(filepara->file);
+#else
+	{
+		int err;
+		gft = DGifOpenFileName(filepara->file, &err);
+	}
 #endif
 	if (gft == NULL)
 		return;
@@ -566,9 +578,10 @@
 						filepara->palette[i].b = cmap->Colors[i].Blue;
 					}
 
+					fbptr = pic_buffer;
 					if (!(gft->Image.Interlace))
 					{
-						for (i = 0; i < py; i++)
+						for (i = 0; i < py; i++, fbptr += px * 3)
 						{
 							if (DGifGetLine(gft, slb, px) == GIF_ERROR)
 								goto ERROR_R;
@@ -577,37 +590,17 @@
 					}
 					else
 					{
-						int IOffset[] = { 0, 4, 2, 1 }; // The way Interlaced image should.
-						int IJumps[] = { 8, 8, 4, 2 };  // be read - offsets and jumps...
 						for (j = 0; j < 4; j++)
 						{
-							for (i = IOffset[j]; i < py; i += IJumps[j])
+							slb = pic_buffer;
+							for (i = 0; i < py; i++)
 							{
-								if (DGifGetLine(gft, pic_buffer + i*px, px) == GIF_ERROR)
+								if (DGifGetLine(gft, slb, px) == GIF_ERROR)
 									goto ERROR_R;
+								slb += px;
 							}
 						}
 					}
-					if (forceRGB) {
-						unsigned char *pic_buffer2 = new unsigned char[px * py * 3];
-						if (pic_buffer2 != NULL) {
-							unsigned char *slb2 = pic_buffer2;
-							slb = pic_buffer;
-							for (j = 0; j < py; j++) {
-								for (i = 0; i < px; i++) {
-									int c = *slb++;
-									*slb2++ = filepara->palette[c].r;
-									*slb2++ = filepara->palette[c].g;
-									*slb2++ = filepara->palette[c].b;
-								}
-							}
-							filepara->bits = 24;
-							filepara->pic_buffer = pic_buffer2;
-							delete [] pic_buffer;
-							delete [] filepara->palette;
-							filepara->palette = NULL;
-						}
-					}
 				}
 				break;
 			case EXTENSION_RECORD_TYPE:
@@ -623,18 +616,24 @@
 	}
 	while (rt != TERMINATE_RECORD_TYPE);
 
-#if GIFLIB_MAJOR > 5 || GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1
-	DGifCloseFile(gft, &extcode);
-#else
+#if !defined(GIFLIB_MAJOR) || ( GIFLIB_MAJOR < 5) || (GIFLIB_MAJOR == 5 && GIFLIB_MINOR == 0)
 	DGifCloseFile(gft);
+#else
+	{
+		int err;
+		DGifCloseFile(gft, &err);
+	}
 #endif
 	return;
 ERROR_R:
-	eDebug("[ePicLoad] <Error gif>");
-#if GIFLIB_MAJOR > 5 || GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1
-	DGifCloseFile(gft, &extcode);
-#else
+	eDebug("[Picload] <Error gif>");
+#if !defined(GIFLIB_MAJOR) || ( GIFLIB_MAJOR < 5) || (GIFLIB_MAJOR == 5 && GIFLIB_MINOR == 0)
 	DGifCloseFile(gft);
+#else
+	{
+		int err;
+		DGifCloseFile(gft, &err);
+	}
 #endif
 }
 
@@ -642,7 +641,6 @@
 
 ePicLoad::ePicLoad():
 	m_filepara(NULL),
-	m_exif(NULL),
 	threadrunning(false),
 	m_conf(),
 	msg_thread(this,1),
@@ -659,7 +657,6 @@
 	background(0),
 	resizetype(1),
 	usecache(false),
-	auto_orientation(false),
 	thumbnailsize(180)
 {
 }
@@ -674,137 +671,130 @@
 {
 	if (threadrunning)
 		waitFinished();
-	if (m_filepara != NULL)
+	if(m_filepara != NULL)
 		delete m_filepara;
-	if (m_exif != NULL) {
-		m_exif->ClearExif();
-		delete m_exif;
-	}
 }
 
 void ePicLoad::thread_finished()
 {
-	threadrunning = false;
+	threadrunning=false;
 }
 
 void ePicLoad::thread()
 {
-	threadrunning = true;
 	hasStarted();
-	if (nice(4))
-	{
-		eDebug("[ePicLoad] thread failed to modify scheduling priority (%m)");
-	}
+	threadrunning=true;
+	nice(4);
 	runLoop();
 }
 
 void ePicLoad::decodePic()
 {
-	getExif(m_filepara->file, m_filepara->id);
+	eDebug("[Picload] decode picture... %s",m_filepara->file);
+
 	switch(m_filepara->id)
 	{
-		case F_PNG:	png_load(m_filepara, m_conf.background);
-				break;
-		case F_JPEG:	m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, m_filepara->max_x, m_filepara->max_y);
-				break;
-		case F_BMP:	m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);
-				break;
-		case F_GIF:	gif_load(m_filepara);
-				break;
+		case F_PNG:	png_load(m_filepara, m_conf.background); break;
+		case F_JPEG:	m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, m_filepara->max_x, m_filepara->max_y);	break;
+		case F_BMP:	m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);	break;
+		case F_GIF:	gif_load(m_filepara); break;
 	}
+
+	if(m_filepara->pic_buffer != NULL)
+		resizePic();
 }
 
 void ePicLoad::decodeThumb()
 {
-	eDebug("[ePicLoad] get Thumbnail... %s", m_filepara->file);
+	eDebug("[Picload] get Thumbnail... %s",m_filepara->file);
 
 	bool exif_thumbnail = false;
 	bool cachefile_found = false;
 	std::string cachefile = "";
 	std::string cachedir = "/.Thumbnails";
 
-	getExif(m_filepara->file, m_filepara->id, 1);
-	if (m_exif && m_exif->m_exifinfo->IsExif)
+	if(m_filepara->id == F_JPEG)
 	{
-		if (m_exif->m_exifinfo->Thumnailstate == 2)
+		Cexif *exif = new Cexif;
+		if(exif->DecodeExif(m_filepara->file, 1))
 		{
-			free(m_filepara->file);
-			m_filepara->file = strdup(THUMBNAILTMPFILE);
-			m_filepara->id = F_JPEG; // imbedded thumbnail seem to be jpeg
-			exif_thumbnail = true;
-			eDebug("[ePicLoad] decodeThumb: Exif Thumbnail found");
-		}
-		//else
-		//	eDebug("[ePicLoad] decodeThumb: NO Exif Thumbnail found");
-		m_filepara->addExifInfo(m_exif->m_exifinfo->CameraMake);
-		m_filepara->addExifInfo(m_exif->m_exifinfo->CameraModel);
-		m_filepara->addExifInfo(m_exif->m_exifinfo->DateTime);
-		char buf[20];
-		snprintf(buf, 20, "%d x %d", m_exif->m_exifinfo->Width, m_exif->m_exifinfo->Height);
-		m_filepara->addExifInfo(buf);
+			if(exif->m_exifinfo->IsExif)
+			{
+				if(exif->m_exifinfo->Thumnailstate==2)
+				{
+					free(m_filepara->file);
+					m_filepara->file = strdup(THUMBNAILTMPFILE);
+					exif_thumbnail = true;
+					eDebug("[Picload] Exif Thumbnail found");
+				}
+				m_filepara->addExifInfo(exif->m_exifinfo->CameraMake);
+				m_filepara->addExifInfo(exif->m_exifinfo->CameraModel);
+				m_filepara->addExifInfo(exif->m_exifinfo->DateTime);
+				char buf[20];
+				snprintf(buf, 20, "%d x %d", exif->m_exifinfo->Width, exif->m_exifinfo->Height);
+				m_filepara->addExifInfo(buf);
+			}
+			exif->ClearExif();
+		}
+		delete exif;
 	}
-	else
-		eDebug("[ePicLoad] decodeThumb: NO Exif info");
 
-	if (!exif_thumbnail && m_conf.usecache)
+	if((! exif_thumbnail) && m_conf.usecache)
 	{
-		if (FILE *f = fopen(m_filepara->file, "rb"))
+		if(FILE *f=fopen(m_filepara->file, "rb"))
 		{
 			int c;
-			int count = 1024*100; // get checksum data out of max 100kB
-			uint32_t crc32 = 0;
-			char crcstr[9];
-			*crcstr = 0;
+			int count = 1024*100;
+			unsigned long crc32 = 0;
+			char crcstr[9];*crcstr=0;
 
-			while (count-- > 0 && (c = getc(f)) != EOF)
+			while ((c=getc(f))!=EOF)
+			{
 				crc32 = crc32_table[((crc32) ^ (c)) & 0xFF] ^ ((crc32) >> 8);
+				if(--count < 0) break;
+			}
 
 			fclose(f);
 			crc32 = ~crc32;
-			sprintf(crcstr, "%08X", crc32);
+			sprintf(crcstr, "%08lX", crc32);
 
 			cachedir = m_filepara->file;
-			size_t pos = cachedir.find_last_of("/");
+			unsigned int pos = cachedir.find_last_of("/");
 			if (pos != std::string::npos)
 				cachedir = cachedir.substr(0, pos) + "/.Thumbnails";
 
 			cachefile = cachedir + std::string("/pc_") + crcstr;
-			if (!access(cachefile.c_str(), R_OK))
+			if(!access(cachefile.c_str(), R_OK))
 			{
 				cachefile_found = true;
 				free(m_filepara->file);
 				m_filepara->file = strdup(cachefile.c_str());
 				m_filepara->id = F_JPEG;
-				eDebug("[ePicLoad] Cache File %s found", cachefile.c_str());
+				eDebug("[Picload] Cache File found");
 			}
 		}
 	}
 
-	switch (m_filepara->id)
+	switch(m_filepara->id)
 	{
-		case F_PNG:	png_load(m_filepara, m_conf.background, true);
-				break;
-		case F_JPEG:	m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, m_filepara->max_x, m_filepara->max_y);
-				break;
-		case F_BMP:	m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);
-				break;
-		case F_GIF:	gif_load(m_filepara, true);
-				break;
+		case F_PNG:	png_load(m_filepara, m_conf.background); break;
+		case F_JPEG:	m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, m_filepara->max_x, m_filepara->max_y);	break;
+		case F_BMP:	m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);	break;
+		case F_GIF:	gif_load(m_filepara); break;
 	}
-	//eDebug("[ePicLoad] getThumb picture loaded %s", m_filepara->file);
 
-	if (exif_thumbnail)
+	if(exif_thumbnail)
 		::unlink(THUMBNAILTMPFILE);
 
-	if (m_filepara->pic_buffer != NULL)
+	if(m_filepara->pic_buffer != NULL)
 	{
-		// Save cachefile
-		if (m_conf.usecache && !exif_thumbnail && !cachefile_found)
+		//save cachefile
+		if(m_conf.usecache && (! exif_thumbnail) && (! cachefile_found))
 		{
-			if (access(cachedir.c_str(), R_OK))
+			if(access(cachedir.c_str(), R_OK))
 				::mkdir(cachedir.c_str(), 0755);
 
-			// Resize for Thumbnail
+			//resize for Thumbnail
 			int imx, imy;
 			if (m_filepara->ox <= m_filepara->oy)
 			{
@@ -817,15 +807,47 @@
 				imy = (int)( (m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox) );
 			}
 
-			// eDebug("[ePicLoad] getThumb resize from %dx%d to %dx%d", m_filepara->ox, m_filepara->oy, imx, imy);
 			m_filepara->pic_buffer = color_resize(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
 			m_filepara->ox = imx;
 			m_filepara->oy = imy;
 
-			if (jpeg_save(cachefile.c_str(), m_filepara->ox, m_filepara->oy, m_filepara->pic_buffer))
-				eDebug("[ePicLoad] getThumb: error saving cachefile");
+			if(jpeg_save(cachefile.c_str(), m_filepara->ox, m_filepara->oy, m_filepara->pic_buffer))
+				eDebug("[Picload] error saving cachefile");
 		}
+
+		resizePic();
+	}
+}
+
+void ePicLoad::resizePic()
+{
+	int imx, imy;
+
+	if (m_conf.aspect_ratio == 0)  // do not keep aspect ration but just fill the destination area
+	{
+		imx = m_filepara->max_x;
+		imy = m_filepara->max_y;
+	}
+	else if ((m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox) <= m_filepara->max_y)
+	{
+		imx = m_filepara->max_x;
+		imy = (int)(m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox);
+	}
+	else
+	{
+		imx = (int)((1.0/m_conf.aspect_ratio) * m_filepara->ox * m_filepara->max_y / m_filepara->oy);
+		imy = m_filepara->max_y;
 	}
+
+	if (m_filepara->bits == 8)
+		m_filepara->pic_buffer = simple_resize_8(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
+	else if (m_conf.resizetype)
+		m_filepara->pic_buffer = color_resize(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
+	else
+		m_filepara->pic_buffer = simple_resize_24(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
+
+	m_filepara->ox = imx;
+	m_filepara->oy = imy;
 }
 
 void ePicLoad::gotMessage(const Message &msg)
@@ -841,11 +863,11 @@
 			msg_main.send(Message(Message::decode_finished));
 			break;
 		case Message::quit: // called from decode thread
-			eDebug("[ePicLoad] decode thread ... got quit msg");
+			eDebug("[Picload] decode thread ... got quit msg");
 			quit(0);
 			break;
 		case Message::decode_finished: // called from main thread
-			//eDebug("[ePicLoad] decode finished... %s", m_filepara->file);
+			//eDebug("[Picload] decode finished... %s", m_filepara->file);
 			if(m_filepara->callback)
 				PictureData(m_filepara->picinfo.c_str());
 			else
@@ -855,15 +877,10 @@
 					delete m_filepara;
 					m_filepara = NULL;
 				}
-				if (m_exif != NULL) {
-					m_exif->ClearExif();
-					delete m_exif;
-					m_exif = NULL;
-				}
 			}
 			break;
 		default:
-			eDebug("[ePicLoad] unhandled thread message");
+			eDebug("unhandled thread message");
 	}
 }
 
@@ -871,7 +888,7 @@
 {
 	if(async && threadrunning && m_filepara != NULL)
 	{
-		eDebug("[ePicLoad] thread running");
+		eDebug("[Picload] thread running");
 		m_filepara->callback = false;
 		return 1;
 	}
@@ -881,16 +898,23 @@
 		delete m_filepara;
 		m_filepara = NULL;
 	}
-	if (m_exif != NULL) {
-		m_exif->ClearExif();
-		delete m_exif;
-		m_exif = NULL;
-	}
 
-	int file_id = getFileType(file);
+	int file_id = -1;
+	unsigned char id[10];
+	int fd = ::open(file, O_RDONLY);
+	if (fd == -1) return 1;
+	::read(fd, id, 10);
+	::close(fd);
+
+	if(id[1] == 'P' && id[2] == 'N' && id[3] == 'G')			file_id = F_PNG;
+	else if(id[6] == 'J' && id[7] == 'F' && id[8] == 'I' && id[9] == 'F')	file_id = F_JPEG;
+	else if(id[0] == 0xff && id[1] == 0xd8 && id[2] == 0xff)		file_id = F_JPEG;
+	else if(id[0] == 'B' && id[1] == 'M' )					file_id = F_BMP;
+	else if(id[0] == 'G' && id[1] == 'I' && id[2] == 'F')			file_id = F_GIF;
+
 	if(file_id < 0)
 	{
-		eDebug("[ePicLoad] <format not supported>");
+		eDebug("[Picload] <format not supported>");
 		return 1;
 	}
 
@@ -902,12 +926,12 @@
 	{
 		delete m_filepara;
 		m_filepara = NULL;
-		eDebug("[ePicLoad] <error in Para>");
+		eDebug("[Picload] <error in Para>");
 		return 1;
 	}
 
 	if (async) {
-		if(what == 1)
+		if(what==1)
 			msg_thread.send(Message(Message::decode_Pic));
 		else
 			msg_thread.send(Message(Message::decode_Thumb));
@@ -934,355 +958,222 @@
 {
 	ePyObject list;
 
-	// FIXME : m_filepara destroyed by getData. Need refactor this but plugins rely in it :(
-	getExif(filename, m_filepara ? m_filepara->id : -1);
-	if(m_exif && m_exif->m_exifinfo->IsExif)
-	{
-		char tmp[256];
-		int pos = 0;
-		list = PyList_New(23);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(filename));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->Version));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->CameraMake));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->CameraModel));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->DateTime));
-		PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d x %d", m_exif->m_exifinfo->Width, m_exif->m_exifinfo->Height));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->FlashUsed));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->Orientation));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->Comments));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->MeteringMode));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->ExposureProgram));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->LightSource));
-		PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", m_exif->m_exifinfo->CompressionLevel));
-		PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", m_exif->m_exifinfo->ISOequivalent));
-		sprintf(tmp, "%.2f", m_exif->m_exifinfo->Xresolution);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		sprintf(tmp, "%.2f", m_exif->m_exifinfo->Yresolution);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(m_exif->m_exifinfo->ResolutionUnit));
-		sprintf(tmp, "%.2f", m_exif->m_exifinfo->Brightness);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		sprintf(tmp, "%.5f sec.", m_exif->m_exifinfo->ExposureTime);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		sprintf(tmp, "%.5f", m_exif->m_exifinfo->ExposureBias);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		sprintf(tmp, "%.5f", m_exif->m_exifinfo->Distance);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		sprintf(tmp, "%.5f", m_exif->m_exifinfo->CCDWidth);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
-		sprintf(tmp, "%.2f", m_exif->m_exifinfo->ApertureFNumber);
-		PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+	Cexif *exif = new Cexif;
+	if(exif->DecodeExif(filename))
+	{
+		if(exif->m_exifinfo->IsExif)
+		{
+			char tmp[256];
+			int pos=0;
+			list = PyList_New(23);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(filename));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->Version));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->CameraMake));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->CameraModel));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->DateTime));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d x %d", exif->m_exifinfo->Width, exif->m_exifinfo->Height));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->FlashUsed));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->Orientation));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->Comments));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->MeteringMode));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->ExposureProgram));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->LightSource));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", exif->m_exifinfo->CompressionLevel));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", exif->m_exifinfo->ISOequivalent));
+			sprintf(tmp, "%.2f", exif->m_exifinfo->Xresolution);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.2f", exif->m_exifinfo->Yresolution);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif->m_exifinfo->ResolutionUnit));
+			sprintf(tmp, "%.2f", exif->m_exifinfo->Brightness);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f sec.", exif->m_exifinfo->ExposureTime);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif->m_exifinfo->ExposureBias);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif->m_exifinfo->Distance);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif->m_exifinfo->CCDWidth);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.2f", exif->m_exifinfo->ApertureFNumber);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+		}
+		else
+		{
+			list = PyList_New(2);
+			PyList_SET_ITEM(list, 0, PyString_FromString(filename));
+			PyList_SET_ITEM(list, 1, PyString_FromString(exif->m_szLastError));
+		}
+		exif->ClearExif();
 	}
 	else
 	{
 		list = PyList_New(2);
 		PyList_SET_ITEM(list, 0, PyString_FromString(filename));
-		PyList_SET_ITEM(list, 1, PyString_FromString(m_exif->m_szLastError));
+		PyList_SET_ITEM(list, 1, PyString_FromString(exif->m_szLastError));
 	}
+	delete exif;
 
 	return list ? (PyObject*)list : (PyObject*)PyList_New(0);
 }
 
-bool ePicLoad::getExif(const char *filename, int fileType, int Thumb)
-{
-	if (!m_exif) {
-		m_exif = new Cexif;
-		if (fileType < 0)
-			fileType = getFileType(filename);
-		return m_exif->DecodeExif(filename, Thumb, fileType);
-	}
-	return true;
-}
-
 int ePicLoad::getData(ePtr<gPixmap> &result)
 {
 	result = 0;
 	if (m_filepara == NULL)
 	{
-		eDebug("[ePicLoad] Weird situation, was not decoding anything!");
+		eDebug("picload - Weird situation, I wasn't decoding anything!");
 		return 1;
 	}
 	if(m_filepara->pic_buffer == NULL)
 	{
 		delete m_filepara;
 		m_filepara = NULL;
-		if (m_exif != NULL) {
-			m_exif->ClearExif();
-			delete m_exif;
-			m_exif = NULL;
-		}
 		return 0;
 	}
 
-	result = new gPixmap(m_filepara->max_x, m_filepara->max_y, m_filepara->bits == 8 ? 8 : 32,
-				NULL, m_filepara->bits == 8 ? gPixmap::accelAlways : gPixmap::accelAuto);
-	gUnmanagedSurface *surface = result->surface;
-
-	// original image    : ox, oy
-	// surface size      : max_x, max_y
-	// after aspect calc : scrx, scry
-	// center image      : xoff, yoff
-	int scrx, scry; // Aspect ratio calculation
-	int orientation = m_conf.auto_orientation ? (m_exif && m_exif->m_exifinfo->Orient ? m_exif->m_exifinfo->Orient : 1) : 1;
-	if (m_conf.aspect_ratio == 0)  // do not keep aspect ratio but just fill the destination area
+	if (m_filepara->bits == 8)
 	{
-		scrx = m_filepara->max_x;
-		scry = m_filepara->max_y;
-	}
-	else if (orientation < 5) {
-		if ((m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox) <= m_filepara->max_y)
-		{
-			scrx = m_filepara->max_x;
-			scry = (int)(m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox);
-		}
-		else
+		result=new gPixmap(m_filepara->max_x, m_filepara->max_y, 8, NULL, gPixmap::accelAlways);
+		gUnmanagedSurface *surface = result->surface;
+		surface->clut.data = m_filepara->palette;
+		surface->clut.colors = m_filepara->palette_size;
+		m_filepara->palette = NULL; // transfer ownership
+		int o_y=0, u_y=0, v_x=0, h_x=0;
+		int extra_stride = surface->stride - surface->x;
+
+		unsigned char *tmp_buffer=((unsigned char *)(surface->data));
+		unsigned char *origin = m_filepara->pic_buffer;
+
+		if(m_filepara->oy < m_filepara->max_y)
 		{
-			scrx = (int)((1.0/m_conf.aspect_ratio) * m_filepara->ox * m_filepara->max_y / m_filepara->oy);
-			scry = m_filepara->max_y;
+			o_y = (m_filepara->max_y - m_filepara->oy) / 2;
+			u_y = m_filepara->max_y - m_filepara->oy - o_y;
 		}
-	}
-	else {
-		if ((m_conf.aspect_ratio * m_filepara->ox * m_filepara->max_x / m_filepara->oy) <= m_filepara->max_y)
+		if(m_filepara->ox < m_filepara->max_x)
 		{
-			scrx = m_filepara->max_x;
-			scry = (int)(m_conf.aspect_ratio * m_filepara->ox * m_filepara->max_x / m_filepara->oy);
+			v_x = (m_filepara->max_x - m_filepara->ox) / 2;
+			h_x = m_filepara->max_x - m_filepara->ox - v_x;
 		}
-		else
+
+		int background;
+		gRGB bg(m_conf.background);
+		background = surface->clut.findColor(bg);
+
+		if(m_filepara->oy < m_filepara->max_y)
 		{
-			scrx = (int)((1.0/m_conf.aspect_ratio) * m_filepara->oy * m_filepara->max_y / m_filepara->ox);
-			scry = m_filepara->max_y;
+			memset(tmp_buffer, background, o_y * surface->stride);
+			tmp_buffer += o_y * surface->stride;
 		}
-	}
-	float xscale = (float)(orientation < 5 ? m_filepara->ox : m_filepara->oy) / (float)scrx; // scale factor as result of screen and image size
-	float yscale = (float)(orientation < 5 ? m_filepara->oy : m_filepara->ox) / (float)scry;
-	int xoff = (m_filepara->max_x - scrx) / 2;  // borders as result of screen and image aspect
-	int yoff = (m_filepara->max_y - scry) / 2;
-	//eDebug("[getData] ox=%d oy=%d max_x=%d max_y=%d scrx=%d scry=%d xoff=%d yoff=%d xscale=%f yscale=%f aspect=%f bits=%d orientation=%d", m_filepara->ox, m_filepara->oy, m_filepara->max_x, m_filepara->max_y, scrx, scry, xoff, yoff, xscale, yscale, m_conf.aspect_ratio, m_filepara->bits, orientation);
-
-	unsigned char *tmp_buffer = ((unsigned char *)(surface->data));
-	unsigned char *origin = m_filepara->pic_buffer;
-	if (m_filepara->bits == 8) {
-		surface->clut.data = m_filepara->palette;
-		surface->clut.colors = m_filepara->palette_size;
-		m_filepara->palette = NULL; // transfer ownership
-	}
 
-	// fill borders with background color
-	if (xoff != 0 || yoff != 0) {
-		unsigned int background;
-		if (m_filepara->bits == 8) {
-			gRGB bg(m_conf.background);
-			background = surface->clut.findColor(bg);
-		}
-		else {
-			background = m_conf.background;
-		}
-		if (yoff != 0) {
-			if (m_filepara->bits == 8)
+		for(int a = m_filepara->oy; a > 0; --a)
+		{
+			if(m_filepara->ox < m_filepara->max_x)
 			{
-				unsigned char* row_buffer;
-				row_buffer = (unsigned char *) tmp_buffer;
-				for (int x = 0; x < m_filepara->max_x; ++x) // fill first line
-					*row_buffer++ = background;
+				memset(tmp_buffer, background, v_x);
+				tmp_buffer += v_x;
 			}
-			else
+
+			memcpy(tmp_buffer, origin, m_filepara->ox);
+			tmp_buffer += m_filepara->ox;
+			origin += m_filepara->ox;
+
+			if(m_filepara->ox < m_filepara->max_x)
 			{
-				unsigned int* row_buffer;
-				row_buffer = (unsigned int *) tmp_buffer;
-				for (int x = 0; x < m_filepara->max_x; ++x) // fill first line
-					*row_buffer++ = background;
+				memset(tmp_buffer, background, h_x);
+				tmp_buffer += h_x;
 			}
-			int y;
-			#pragma omp parallel for
-			for (y = 1; y < yoff; ++y) // copy from first line
-				memcpy(tmp_buffer + y*surface->stride, tmp_buffer,
-					m_filepara->max_x * surface->bypp);
-			#pragma omp parallel for
-			for (y = yoff + scry; y < m_filepara->max_y; ++y)
-				memcpy(tmp_buffer + y * surface->stride, tmp_buffer,
-					m_filepara->max_x * surface->bypp);
+
+			tmp_buffer += extra_stride;
 		}
-		if (xoff != 0) {
-			if (m_filepara->bits == 8)
-			{
-				unsigned char* row_buffer = (unsigned char *) (tmp_buffer + yoff * surface->stride);
-				int x;
-				for (x = 0; x < xoff; ++x) // fill left side of first line
-					*row_buffer++ = background;
-				row_buffer += scrx;
-				for (x = xoff + scrx; x < m_filepara->max_x; ++x) // fill right side of first line
-					*row_buffer++ = background;
-			}
-			else {
-				unsigned int* row_buffer = (unsigned int *) (tmp_buffer + yoff * surface->stride);
-				int x;
-				for (x = 0; x < xoff; ++x) // fill left side of first line
-					*row_buffer++ = background;
-				row_buffer += scrx;
-				for (x = xoff + scrx; x < m_filepara->max_x; ++x) // fill right side of first line
-					*row_buffer++ = background;
-			}
-			#pragma omp parallel for
-			for (int y = yoff + 1; y < scry; ++y) { // copy from first line
-				memcpy(tmp_buffer + y*surface->stride,
-					tmp_buffer + yoff * surface->stride,
-					xoff * surface->bypp);
-				memcpy(tmp_buffer + y*surface->stride + (xoff + scrx) * surface->bypp,
-					tmp_buffer + yoff * surface->stride + (xoff + scrx) * surface->bypp,
-					(m_filepara->max_x - scrx - xoff) * surface->bypp);
-			}
+
+		if(m_filepara->oy < m_filepara->max_y)
+		{
+			memset(tmp_buffer, background, u_y * surface->stride);
 		}
-		tmp_buffer += yoff * surface->stride + xoff * surface->bypp;
 	}
-
-	// Setup input image base pointers and x/y increment factors according to orientation
-	//     1        2       3      4         5            6           7          8
-	//
-	//   888888  888888      88  88      8888888888  88                  88  8888888888
-	//   88          88      88  88      88  88      88  88          88  88      88  88
-	//   8888      8888    8888  8888    88          8888888888  8888888888          88
-	//   88          88      88  88
-	//   88          88  888888  888888
-	//
-	// ori  ori-1   yfax    xfac    origin
-	// 0001 000      b * x   b      0
-	// 0010 001      b * x  -b                                    b * (x - 1)
-	// 0011 010     -b * x  -b      b * yscale * (sy - 1) * x  +  b * (x - 1)
-	// 0100 011     -b * x   b      b * yscale * (sy - 1) * x
-	// 0101 100      b       b * x  0
-	// 0110 101      b      -b * x                              b * (y - 1) * x
-	// 0111 110     -b      -b * x  b * yscale * (sy - 1)   +   b * (y - 1) * x
-	// 1000 111     -b       b * x  b * yscale * (sy - 1)
-	int bpp = m_filepara->bits / 8;
-#if 0
-	int iyfac = ((orientation-1) & 0x2) ? -bpp : bpp;
-	int ixfac = (orientation & 0x2) ? -bpp : bpp;
-	if (orientation < 5)
-		iyfac *= m_filepara->ox;
 	else
-		ixfac *= m_filepara->ox;
-	if (((orientation-1) & 0x6) == 2)
-		origin += bpp * (int)(yscale * (scry - 1)) * m_filepara->ox;
-	if (((orientation-1) & 0x6) == 6)
-		origin += bpp * (int)(yscale * (scry - 1));
-	if (((orientation) & 0x6) == 2)
-		origin += bpp * (m_filepara->ox - 1);
-	if (((orientation) & 0x6) == 6)
-		origin += bpp * (m_filepara->oy - 1) * m_filepara->ox;
-#else
-	int ixfac;
-	int iyfac;
-	if (orientation < 5) {
-		if (orientation == 1 || orientation == 2)
-			iyfac = bpp * m_filepara->ox; // run y across rows
-		else {
-			origin += bpp * (int)(yscale * (scry - 1)) * m_filepara->ox;
-			iyfac = -bpp * m_filepara->ox;
-		}
-		if (orientation == 2 || orientation == 3) {
-			origin += bpp * (m_filepara->ox - 1);
-			ixfac = -bpp;
+	{
+		result=new gPixmap(m_filepara->max_x, m_filepara->max_y, 32, NULL, gPixmap::accelAuto);
+		gUnmanagedSurface *surface = result->surface;
+		int o_y=0, u_y=0, v_x=0, h_x=0;
+
+		unsigned char *tmp_buffer=((unsigned char *)(surface->data));
+		unsigned char *origin = m_filepara->pic_buffer;
+		int extra_stride = surface->stride - (surface->x * surface->bypp);
+
+		if(m_filepara->oy < m_filepara->max_y)
+		{
+			o_y = (m_filepara->max_y - m_filepara->oy) / 2;
+			u_y = m_filepara->max_y - m_filepara->oy - o_y;
 		}
-		else
-			ixfac = bpp;
-	}
-	else {
-		if (orientation == 5 || orientation == 6)
-			iyfac = bpp;
-		else {
-			origin += bpp * (int)(yscale * (scry - 1));
-			iyfac = -bpp ;
-		}
-		if (orientation == 6 || orientation == 7) {
-			origin += bpp * (m_filepara->oy - 1) * m_filepara->ox;
-			ixfac = -bpp * m_filepara->ox;
+		if(m_filepara->ox < m_filepara->max_x)
+		{
+			v_x = (m_filepara->max_x - m_filepara->ox) / 2;
+			h_x = m_filepara->max_x - m_filepara->ox - v_x;
 		}
-		else
-			ixfac = bpp * m_filepara->ox;
-	}
-#endif
-	// Build output according to screen y by x loops
-	// Fill surface with image data, resize and correct for orientation on the fly
-	if (m_filepara->bits == 8)
-	{
-		#pragma omp parallel for
-		for (int y = 0; y < scry; ++y) {
-			const unsigned char *irow, *irowy = origin + iyfac * (int)(y * yscale);
-			unsigned char *srow = tmp_buffer + surface->stride * y;
-			float xind = 0.0;
-			for (int x = 0; x < scrx; ++x) {
-				irow = irowy + ixfac * (int)xind;
-				*srow++ = *irow;
-				xind += xscale;
+
+		int background = m_conf.background;
+		if(m_filepara->oy < m_filepara->max_y)
+		{
+			for (int y = o_y; y != 0; --y)
+			{
+				int* row_buffer = (int*)tmp_buffer;
+				for (int x = m_filepara->ox; x !=0; --x)
+					*row_buffer++ = background;
+				tmp_buffer += surface->stride;
 			}
 		}
-	}
-	else // 24-bit images
-	{
-		#pragma omp parallel for
-		for (int y = 0; y < scry; ++y) {
-			const unsigned char *irow, *irowy = origin + iyfac * (int)(yscale * y);
-			unsigned char *srow = tmp_buffer + surface->stride * y;
-			float xind = 0.0;
-
-			if (m_conf.resizetype != 1) {
-				// simple resizing
-				for (int x = 0; x < scrx; ++x) {
-					irow = irowy + ixfac * (int)xind;
-					srow[2] = irow[0];
-					srow[1] = irow[1];
-					srow[0] = irow[2];
-					srow[3] = 0xFF; // alpha
-					srow += 4;
-					xind += xscale;
+
+		for(int a = m_filepara->oy; a > 0; --a)
+		{
+			if(m_filepara->ox < m_filepara->max_x)
+			{
+				for(int b = v_x; b != 0; --b)
+				{
+					*(int*)tmp_buffer = background;
+					tmp_buffer += 4;
 				}
 			}
-			else {
-				// color average resizing
-				// determine block range for resize
-				int yr = (int)((y+1) * yscale) - (int) (y * yscale);
-				if (y + yr >= scry)
-					yr = scry - y - 1;
-				for (int x = 0; x < scrx; x++) {
-					// determine x range for resize
-					int xr = (int)(xind + xscale) - (int) xind;
-					if (x + xr >= scrx)
-						xr = scrx - x - 1;
-					int r = 0;
-					int g = 0;
-					int b = 0;
-					int sq = 0;
-					irow = irowy + ixfac * (int)xind;
-					// average over all pixels in x by y block
-					for (int l = 0; l <= yr; l++) {
-						for (int k = 0; k <= xr; k++) {
-							r += irow[0];
-							g += irow[1];
-							b += irow[2];
-							sq++;
-							irow += ixfac;
-						}
-						irow -= (xr + 1) * ixfac; // go back to starting point of this subrow
-						irow += iyfac;
-					}
-					srow[2] = r / sq;
-					srow[1] = g / sq;
-					srow[0] = b / sq;
-					srow[3] = 0xFF; // alpha
-					srow += 4;
-					xind += xscale;
+
+			for(int b = m_filepara->ox; b != 0; --b)
+			{
+				tmp_buffer[2] = *origin;
+				++origin;
+				tmp_buffer[1] = *origin;
+				++origin;
+				tmp_buffer[0] = *origin;
+				++origin;
+				tmp_buffer[3] = 0xFF; // alpha
+				tmp_buffer += 4;
+			}
+
+			if(m_filepara->ox < m_filepara->max_x)
+			{
+				for(int b = h_x; b != 0; --b)
+				{
+					*(int*)tmp_buffer = background;
+					tmp_buffer += 4;
 				}
 			}
+
+			tmp_buffer += extra_stride;
+		}
+
+		if(m_filepara->oy < m_filepara->max_y)
+		{
+			for (int y = u_y; y != 0; --y)
+			{
+				int* row_buffer = (int*)tmp_buffer;
+				for (int x = m_filepara->ox; x !=0; --x)
+					*row_buffer++ = background;
+				tmp_buffer += surface->stride;
+			}
 		}
 	}
 
-	delete m_filepara; // so caller can start a new decode in background
+	delete m_filepara;
 	m_filepara = NULL;
-	if (m_exif) {
-		m_exif->ClearExif();
-		delete m_exif;
-		m_exif = NULL;
-	}
 
 	return 0;
 }
@@ -1302,52 +1193,26 @@
 		bool useCache		= PyInt_AsLong(PySequence_Fast_GET_ITEM(fast, 4));
 		int resizeType	        = PyInt_AsLong(PySequence_Fast_GET_ITEM(fast, 5));
 		const char *bg_str	= PyString_AsString(PySequence_Fast_GET_ITEM(fast, 6));
-		bool auto_orientation	= (PySequence_Size(val) > 7) ?
-						PyInt_AsLong(PySequence_Fast_GET_ITEM(fast, 7)) :
-						0;
 
-		return setPara(width, height, aspectRatio, as, useCache, resizeType, bg_str, auto_orientation);
+		return setPara(width, height, aspectRatio, as, useCache, resizeType, bg_str);
 	}
 	return 1;
 }
 
-RESULT ePicLoad::setPara(int width, int height, double aspectRatio, int as, bool useCache, int resizeType, const char *bg_str, bool auto_orientation)
+RESULT ePicLoad::setPara(int width, int height, double aspectRatio, int as, bool useCache, int resizeType, const char *bg_str)
 {
 	m_conf.max_x = width;
 	m_conf.max_y = height;
 	m_conf.aspect_ratio = as == 0 ? 0.0 : aspectRatio / as;
 	m_conf.usecache	= useCache;
-	m_conf.auto_orientation	= auto_orientation;
 	m_conf.resizetype = resizeType;
 
 	if(bg_str[0] == '#' && strlen(bg_str)==9)
-		m_conf.background = strtoul(bg_str+1, NULL, 16) | 0xFF000000;
-	eDebug("[ePicLoad] setPara max-X=%d max-Y=%d aspect_ratio=%lf cache=%d resize=%d bg=#%08X auto_orient=%d",
+		m_conf.background = strtoul(bg_str+1, NULL, 16);
+	eDebug("[Picload] setPara max-X=%d max-Y=%d aspect_ratio=%lf cache=%d resize=%d bg=#%08X",
 			m_conf.max_x, m_conf.max_y, m_conf.aspect_ratio,
-			(int)m_conf.usecache, (int)m_conf.resizetype, m_conf.background, m_conf.auto_orientation);
-	return 1;
-}
-
-int ePicLoad::getFileType(const char * file)
-{
-	unsigned char id[10];
-	int fd = ::open(file, O_RDONLY);
-	if (fd == -1)
-		return -1;
-	if (::read(fd, id, 10) != 10)
-	{
-		eDebug("[ePicLoad] getFileType failed to read magic num");
-		close(fd);
-		return -1;
-	}
-	::close(fd);
-
-	if      (id[1] == 'P'  && id[2] == 'N'  && id[3] == 'G')			return F_PNG;
-	else if (id[6] == 'J'  && id[7] == 'F'  && id[8] == 'I' && id[9] == 'F')	return F_JPEG;
-	else if (id[0] == 0xff && id[1] == 0xd8 && id[2] == 0xff)			return F_JPEG;
-	else if (id[0] == 'B'  && id[1] == 'M' )					return F_BMP;
-	else if (id[0] == 'G'  && id[1] == 'I'  && id[2] == 'F')			return F_GIF;
-	return -1;
+			(int)m_conf.usecache, (int)m_conf.resizetype, m_conf.background);
+	return 1;	
 }
 
 //------------------------------------------------------------------------------------
@@ -1357,6 +1222,7 @@
 {
 	long asp1, asp2;
 	result = 0;
+	eDebug("deprecated loadPic function used!!! please use the non blocking version! you can see demo code in Pictureplayer plugin... this function is removed in the near future!");
 	ePicLoad mPL;
 
 	switch(aspect)
diff -ruN b/lib/gdi/picload.h a/lib/gdi/picload.h
--- b/lib/gdi/picload.h	2019-12-06 20:50:26.893711285 +0300
+++ a/lib/gdi/picload.h	2019-12-06 20:49:02.000000000 +0300
@@ -2,7 +2,6 @@
 #define __picload_h__
 
 #include <lib/gdi/gpixmap.h>
-#include <lib/gdi/picexif.h>
 #include <lib/base/thread.h>
 #include <lib/python/python.h>
 #include <lib/base/message.h>
@@ -23,7 +22,7 @@
 	int oy;
 	std::string picinfo;
 	bool callback;
-
+	
 	Cfilepara(const char *mfile, int mid, std::string size):
 		file(strdup(mfile)),
 		pic_buffer(NULL),
@@ -36,14 +35,14 @@
 	{
 		picinfo += "\n" + size + "\n";
 	}
-
+	
 	~Cfilepara()
 	{
-		if (pic_buffer != NULL)	delete [] pic_buffer;
-		if (palette != NULL) delete [] palette;
+		if (pic_buffer != NULL)	delete pic_buffer;
+		if (palette != NULL) delete palette;
 		free(file);
 	}
-
+	
 	void addExifInfo(std::string val) { picinfo += val + "\n"; }
 };
 #endif
@@ -52,13 +51,15 @@
 {
 	DECLARE_REF(ePicLoad);
 
+	enum{ F_PNG, F_JPEG, F_BMP, F_GIF};
+	
 	void decodePic();
 	void decodeThumb();
+	void resizePic();
 
 	Cfilepara *m_filepara;
-	Cexif *m_exif;
 	bool threadrunning;
-
+	
 	struct PConf
 	{
 		int max_x;
@@ -67,12 +68,11 @@
 		int background;
 		bool resizetype;
 		bool usecache;
-		bool auto_orientation;
 		int thumbnailsize;
 		int test;
 		PConf();
 	} m_conf;
-
+	
 	struct Message
 	{
 		int type;
@@ -92,19 +92,17 @@
 	void thread();
 	int startThread(int what, const char *file, int x, int y, bool async=true);
 	void thread_finished();
-	bool getExif(const char *filename, int fileType=F_JPEG, int Thumb=0);
-	int getFileType(const char * file);
 public:
 	void waitFinished();
 	PSignal1<void, const char*> PictureData;
 
 	ePicLoad();
 	~ePicLoad();
-
+	
 	RESULT startDecode(const char *filename, int x=0, int y=0, bool async=true);
 	RESULT getThumbnail(const char *filename, int x=0, int y=0, bool async=true);
 	RESULT setPara(PyObject *val);
-	RESULT setPara(int width, int height, double aspectRatio, int as, bool useCache, int resizeType, const char *bg_str, bool auto_orientation);
+	RESULT setPara(int width, int height, double aspectRatio, int as, bool useCache, int resizeType, const char *bg_str);
 	PyObject *getInfo(const char *filename);
 	SWIG_VOID(int) getData(ePtr<gPixmap> &SWIG_OUTPUT);
 };
